<!DOCTYPE html>
<html>
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
<title>LUGATANI - Connector Animation</title>
<script>
  // Prevent scroll restoration on reload (must be before GSAP loads)
  if ('scrollRestoration' in history) {
    history.scrollRestoration = 'manual';
  }
  window.scrollTo(0, 0);
</script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/gsap/3.12.2/gsap.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/gsap/3.12.2/ScrollTrigger.min.js"></script>

<style>
* { margin: 0; padding: 0; box-sizing: border-box; }

/* Regular Montserrat - non-italic */
@font-face {
  font-family: 'Montserrat';
  src: url('Montserrat/Montserrat-VariableFont_wght.ttf') format('truetype');
  font-style: normal;
  font-weight: 100 900;
  font-display: swap;
}

/* Italic Montserrat */
@font-face {
  font-family: 'Montserrat';
  src: url('Montserrat/Montserrat-Italic-VariableFont_wght.ttf') format('truetype');
  font-style: italic;
  font-weight: 100 900;
  font-display: swap;
}

html, body {
  background: #111;
  font-family: 'Montserrat', -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Helvetica, Arial, sans-serif;
  overflow-x: hidden;
  scrollbar-width: none;
}
html::-webkit-scrollbar, body::-webkit-scrollbar { display: none; }

/* Prevent image dragging and touch callout on iOS globally */
img {
  -webkit-user-drag: none;
  user-select: none;
  -webkit-user-select: none;
  -moz-user-select: none;
  -ms-user-select: none;
  -webkit-touch-callout: none;
}

/* Disable selection and dragging globally for a smooth experience */
html, body, * {
  -webkit-user-select: none;
  -moz-user-select: none;
  -ms-user-select: none;
  user-select: none;
  -webkit-touch-callout: none; /* iOS long-press menu */
}

.loader-overlay {
  position: fixed;
  top: 0; left: 0;
  width: 100%; height: 100%;
  background: #009844;
  display: flex;
  flex-direction: column;
  align-items: center;
  justify-content: center;
  z-index: 9999;
  transition: opacity 0.6s ease, visibility 0.6s ease;
}
.loader-overlay.hidden {
  opacity: 0;
  visibility: hidden;
  pointer-events: none;
}
.loader-content {
  display: flex;
  flex-direction: column;
  align-items: center;
  justify-content: flex-start;
  height: 100vh; /* full viewport so we can place percent at middle */
}
.loader-percent {
  font-size: 40px; /* explicit size per request */
  font-weight: 700;
  font-style: italic;
  color: black;
  /* place percent starting from middle of viewport */
  /* shift percent a bit higher so the connecting line can sit below it and both remain on-screen */
  margin-top: calc(38vh - 45px);
  margin-bottom: 20px; /* small gap below percent */
}
/* Line images that connect percent to arrow */
.loader-line {
  width: 100%;
  display: flex;
  flex-direction: column;
  align-items: center;
  justify-content: flex-start;
  gap: 4px;
  pointer-events: none; /* individual images can enable pointer-events when ready */

  /* Ensure the line always starts directly below the percentage.
     Remove the previous large negative nudge and rely on the percent's
     margin-bottom to create spacing. */
  margin-top: 3vh;
  margin-bottom: 20px;
}

/* Small tweak for very small viewports to keep spacing comfortable */
@media (max-height: 480px) {
  .loader-line {
    margin-bottom: 12px;
  }
}
.loader-line img {
  display: block;
  max-width: 90%;
  height: auto;
  transition: transform 0.12s linear, opacity 0.12s linear;
}
/* filete grows downward from its top so it appears to extend */
#filete-img {
  transform-origin: center top;
  transform: scaleY(0);
  opacity: 0;
}
/* ponta stays visible but can be moved slightly to connect */
#ponta-img {
  transform-origin: center center;
  transition: transform 0.12s linear, opacity 0.12s linear;
  opacity: 0;
}
/* When ponta is ready-to-click, give a subtle affordance */
#ponta-img.ready-to-click {
  cursor: pointer;
  transform: translateY(0) scale(1.02);
  transition: transform 0.18s ease, opacity 0.12s linear;
  pointer-events: auto; /* allow clicks once ready */
  z-index: 30;
}

/* When the loader-line is ready, make it clickable too (cursor hint) */
.loader-line.ready-to-click {
  cursor: pointer;
  pointer-events: auto; /* enable clicks on the line container */
}

.panel {
  height: 100vh;
  display: flex;
  align-items: center;
  justify-content:center;
  background: #111;
  position: relative;
  overflow: hidden;

}

.txt { 
  text-align: left; 
  line-height: 0.95; 
  overflow: visible; 
  padding: 40px 40px;
  margin-left: 5%;
  max-width: 100%;
  width: auto;
  user-select: none;
  -webkit-user-select: none;
  -moz-user-select: none;
  -ms-user-select: none;
  cursor: default;
}

.line {
  font-size: clamp(28px, 8vw, 110px);
  font-weight: 800;
  color: #009844;
  transform: skewX(-10deg);
  display: flex;
  gap: 8px;
  margin-bottom: 5px;
  justify-content: flex-start;
  flex-wrap: nowrap;
  cursor: default;
}

.word { 
  display: inline-block; 
  transition: color 0.4s ease;
  opacity: 0;
  cursor: default;
}
.word.from-left {
  transform: translateX(-100vw);
}
.word.from-right {
  transform: translateX(100vw);
}
.word.passed { color: #006830; }

.connection-point { color: #009844; transition: color 0.4s ease; }
.connection-point.passed { color: #00c853; }

svg.connector-svg {
  position: fixed;
  top: 0; left: 0;
  width: 200vw; height: 100%;
  pointer-events: none;
  z-index: 50;
  overflow: visible;
}

svg.connector-svg path {
  stroke: white;
  stroke-width: 2px;
  stroke-linecap: round;
  fill: none;
  transition: filter 0.3s ease;
}

svg.connector-svg path.glowing {
  filter: drop-shadow(0 0 4px rgba(255, 255, 255, 0.6)) 
          drop-shadow(0 0 8px rgba(0, 152, 68, 0.8))
          drop-shadow(0 0 12px rgba(0, 152, 68, 0.5));
}

svg.connector-svg path.intermittent {
  stroke-dasharray: 20 10;
}

svg.connector-svg line#vertical-line {
  /* Solid straight line - no dashes */
  stroke-linecap: round;
  transition: opacity 0.5s ease;
}

svg.connector-svg circle {
  fill: white;
  filter: drop-shadow(0 0 8px rgba(126, 227, 183, 0.9));
}

.next-section {
  height: 100vh;
  display: flex;
  align-items: center;
  justify-content: center;
  background: #009844;
}

.hamburger-menu {
  position: fixed;
  top: 50%;
  left: 50%;
  transform: translate(-50%, -50%);
  display: flex;
  flex-direction: column;
  align-items: center;
  gap: 8px;
  cursor: pointer;
  padding: 20px;
  z-index: 100;
  opacity: 0;
  pointer-events: none;
  transition: opacity 0.3s ease;
}

.hamburger-menu.visible {
  opacity: 1;
  pointer-events: auto;
}

/* Use image for hamburger and hide bar elements visually (kept for JS fallback) */
.hamburger-menu img {
  width: 140px;
  height: auto;
  display: block;
}
.hamburger-menu .bar {
  display: none !important;
}
.track-trace-link {
  position: fixed;
  bottom: 80px;
  left: 50%;
  transform: translateX(-50%);
  color: white;
  text-decoration: none;
  font-family: 'Montserrat', Arial, Helvetica, sans-serif;
  font-size: 24px;
  font-weight: bold;
  font-style: italic;
  letter-spacing: 1px;
  z-index: 100;
  opacity: 0;
  pointer-events: none;
  transition: opacity 0.3s ease, color 0.3s ease;
}

.track-trace-link.visible {
  opacity: 1;
  pointer-events: auto;
}

.track-trace-link:hover {
  color: #111; /* hover black */
  text-decoration: underline;
}

.hamburger-menu .bar {
  width: 40px;
  height: 4px;
  background: white;
  border-radius: 2px;
  transition: all 0.3s ease;
}

.hamburger-menu:hover .bar {
  background: #111;
}

/* Scroll indicator that appears when idle */
.scroll-indicator {
  position: fixed;
  bottom: 40px;
  left: 50%;
  transform: translateX(-50%);
  display: flex;
  flex-direction: column;
  align-items: center;
  gap: 8px;
  z-index: 80;
  opacity: 0;
  pointer-events: none;
  transition: opacity 0.5s ease;
}

.scroll-indicator.visible {
  opacity: 1;
  pointer-events: auto;
}

.scroll-indicator-text {
  color: white;
  font-size: 12px;
  font-weight: 500;
  letter-spacing: 2px;
  text-transform: uppercase;
}

.scroll-indicator-arrow {
  width: 20px;
  height: 20px;
  border-right: 2px solid white;
  border-bottom: 2px solid white;
  transform: rotate(45deg);
  animation: scrollBounce 1.5s ease-in-out infinite;
}

@keyframes scrollBounce {
  0%, 100% {
    transform: rotate(45deg) translateY(0);
    opacity: 1;
  }
  50% {
    transform: rotate(45deg) translateY(8px);
    opacity: 0.5;
  }
}

/* Menu box that opens on hamburger click */
.menu-box {
  position: fixed;
  top: 50%;
  left: 50%;
  transform: translate(-50%, -50%) scale(0);
  width: 200px;
  height: 150px;
  background: #009844;
  border-radius: 12px;
  z-index: 99;
  opacity: 0;
  pointer-events: none;
  transition: transform 0.3s ease, opacity 0.3s ease;
  box-shadow: 0 4px 20px rgba(0, 152, 68, 0.4);
  display: flex;
  flex-direction: column;
  align-items: center;
  justify-content: center;
  gap: 15px;
  padding: 20px;
}

.menu-box.open {
  transform: translate(-50%, -50%) scale(1);
  opacity: 1;
  pointer-events: auto;
}

.menu-box a {
  color: white;
  text-decoration: none;
  font-size: 16px;
  font-weight: 600;
  transition: color 0.2s ease;
}

.menu-box a:hover {
  color: #111;
}

/* Hamburger animation when menu is open */
.hamburger-menu.active .bar:nth-child(1) {
  transform: rotate(45deg) translate(8px, 8px);
}

.hamburger-menu.active .bar:nth-child(2) {
  opacity: 0;
}

.hamburger-menu.active .bar:nth-child(3) {
  transform: rotate(-45deg) translate(8px, -8px);
}

/* ========== MOBILE STYLES ========== */
@media screen and (max-width: 768px) {
  /* Loader - bigger percentage */
  .loader-percent {
    font-size: clamp(28px, 10vw, 64px);
  }
  
  /* make ponta image smaller on mid-size screens */
  #ponta-img {
    width: 50px;
  }
  /* keep the connecting line below the percent on medium screens */
  .loader-line { margin-top: 2.5vh; }
  
  /* Main text - keep left aligned but adjust padding */
  .txt {
    padding: 15px 15px;
    margin-left: 3%;
  }
  
  .line {
    font-size: clamp(24px, 10vw, 70px);
    gap: 5px;
  }
  
  /* Hamburger - bigger */
  .hamburger-menu {
    gap: 10px;
    padding: 25px;
  }
  
  .hamburger-menu .bar {
    width: 55px;
    height: 5px;
  }
  
  /* Track & Trace link */
  .track-trace-link {
    bottom: 70px;
    font-size: 18px;
  }
  
  /* Scroll indicator */
  .scroll-indicator {
    bottom: 30px;
  }
  
  .scroll-indicator-text {
    font-size: 10px;
  }
  
  .scroll-indicator-arrow {
    width: 16px;
    height: 16px;
  }
}

/* Extra small devices (phones in portrait) */
@media screen and (max-width: 480px) {
  .loader-percent {
    font-size: clamp(36px, 12vw, 72px);
  }
  
  /* make ponta image smaller on extra-small screens */
  #ponta-img {
    width: 60px;
  }
  /* keep the connecting line below the percent on extra-small phones */
  .loader-line { margin-top: 1.5vh; }
  
  .txt {
    padding: 10px 10px;
    margin-left: 2%;
  }
  
  .line {
    font-size: clamp(18px, 9vw, 55px);
    gap: 3px;
    margin-bottom: 2px;
  }
  
  .hamburger-menu {
    gap: 12px;
    padding: 30px;
  }
  
  .hamburger-menu .bar {
    width: 65px;
    height: 6px;
    border-radius: 3px;
  }
  
  /* Track & Trace link */
  .track-trace-link {
    bottom: 60px;
    font-size: 16px;
  }
}
</style>
</head>
<body>

<div class="loader-overlay" id="loader">
  <div class="loader-content">
    <div class="loader-percent" id="loader-percent">0%</div>
    <!-- replace previous line with two images that form the connecting line -->
    <div class="loader-line" id="loader-line">
  <!-- filete should be above and grow downward toward the ponta tip -->
  <img src="filete.png" alt="filete" id="filete-img" draggable="false">
  <img src="ponta.png" alt="ponta" id="ponta-img" draggable="false">
    </div>

    <!-- removed separate arrow element; ponta/filete images are used for the loader visuals -->
  </div>
</div>

<svg class="connector-svg" id="connector-svg">
  <defs>
    <linearGradient id="lineGradient" x1="0%" y1="0%" x2="0%" y2="100%">
      <stop offset="0%" style="stop-color: white; stop-opacity: 1" />
      <stop offset="40%" style="stop-color: white; stop-opacity: 1" />
      <stop offset="100%" style="stop-color: #009844; stop-opacity: 1" />
    </linearGradient>
  </defs>
  <path id="connector-path"></path>
  <line id="vertical-line" stroke="white" stroke-width="2" opacity="0"></line>
  <!-- Place dots off-canvas initially (cx/cy) and hide visibility to avoid a flash at 0,0 -->
  <circle id="dot-1" r="5" cx="-100" cy="-100" opacity="0" style="visibility:hidden"></circle>
  <circle id="dot-2" r="5" cx="-100" cy="-100" opacity="0" style="visibility:hidden"></circle>
  <circle id="dot-3" r="5" cx="-100" cy="-100" opacity="0" style="visibility:hidden"></circle>
  <circle id="dot-4" r="5" cx="-100" cy="-100" opacity="0" style="visibility:hidden"></circle>
  <circle id="dot-5" r="5" cx="-100" cy="-100" opacity="0" style="visibility:hidden"></circle>
  <circle id="dot-6" r="5" cx="-100" cy="-100" opacity="0" style="visibility:hidden"></circle>
  <circle id="dot-7" r="5" cx="-100" cy="-100" opacity="0" style="visibility:hidden"></circle>
</svg>

<section class="panel" id="main-panel">
  <div class="txt">
    <div class="line">
      <span class="word from-left stays">LO<span class="connection-point" id="letter-1">R</span>EM</span>
      <span class="word from-right vanishes">IPSUM</span>
    </div>
    <div class="line">
      <span class="word from-left vanishes">DOLOR</span>
      <span class="word from-right stays"><span class="connection-point" id="letter-2">S</span><span class="connection-point" id="letter-3">I</span>T</span>
      <span class="word from-left vanishes">AMET</span>
    </div>
    <div class="line">
      <span class="word from-right stays">CONSEC<span class="connection-point" id="letter-4">T</span>ET<span class="connection-point" id="letter-5">U</span>R</span>
    </div>
    <div class="line">
      <span class="word from-left stays">ADIPI<span class="connection-point" id="letter-6">S</span>CING</span>
      <span class="word from-right vanishes">ELIT</span>
    </div>
  </div>
</section>

<!-- Fixed hamburger menu that appears during gradient animation -->
<div class="hamburger-menu" id="hamburger">
  <img id="hamburger-img" src="4_WebLUGATANI_AnimINICIAL_TransMENU_RASTERIZED.png" alt="menu" />
  <div class="bar"></div>
  <div class="bar"></div>
  <div class="bar"></div>
</div>

<!-- Track & Trace link below hamburger -->
<a href="https://lugatani.pt/en" class="track-trace-link" id="track-trace">Track & Trace</a>

<!-- Scroll indicator that appears when idle -->
<div class="scroll-indicator" id="scroll-indicator">
  <span class="scroll-indicator-text">Scroll</span>
  <div class="scroll-indicator-arrow"></div>
</div>

<section class="next-section" id="menu-section">
</section>

<script>
gsap.registerPlugin(ScrollTrigger);

var loader = document.getElementById('loader');
var loaderPercent = document.getElementById('loader-percent');
// Use the ponta image as the clickable loader trigger instead of a separate arrow element
var loaderTrigger = document.getElementById('ponta-img');
// Also reference the whole loader line container so it can be clickable when ready
var loaderLine = document.getElementById('loader-line');
var percent = 0;
var maxLineHeight = 100;
var resourcesLoaded = false;
var animationComplete = false;

// Track loading progress
var totalResources = 0;
var loadedResources = 0;

function updateLoaderDisplay(targetPercent) {
  loaderPercent.textContent = Math.floor(targetPercent) + '%';
  // Update visual connection between line and arrow as percentage changes
  updateLoaderVisuals(Math.floor(targetPercent));
}

function checkAllReady() {
  if (resourcesLoaded && percent >= 100) {
    animationComplete = true;
    // Ensure visuals reach final state and animate the line to the ponta tip,
    // then automatically enter the site (hide loader and start reveal).
    var fileteImg = document.getElementById('filete-img');
    var pontaImg = document.getElementById('ponta-img');

    // Put visuals in final state immediately as a baseline
    updateLoaderVisuals(100);

    // Give a small, smooth GSAP animation to extend the filete and nudge the ponta
    try {
      if (fileteImg) {
        gsap.to(fileteImg, { duration: 0.45, scaleY: 1, opacity: 1, ease: 'power2.out' });
      }
      if (pontaImg) {
        // animate a small drop/nudge so it sits on the tip of the extended line
        gsap.to(pontaImg, { duration: 0.45, y: 6, opacity: 1, ease: 'power2.out' });
      }
    } catch (e) {
      // If GSAP isn't available for any reason, fall back to setting final styles
      if (fileteImg) { fileteImg.style.transform = 'scaleY(1)'; fileteImg.style.opacity = '1'; }
      if (pontaImg) { pontaImg.style.transform = 'translateY(6px)'; pontaImg.style.opacity = '1'; }
    }

    // Let the visuals settle to final state, but DO NOT auto-enter.
    // Users should click the ponta (tip) to enter. Indicate readiness and enable clicking.
    try {
      if (pontaImg) {
        // small pulse so users notice it's interactive
        gsap.fromTo(pontaImg, { scale: 0.98 }, { duration: 0.6, scale: 1.02, yoyo: true, repeat: 1, ease: 'power1.inOut' });
      }
    } catch (e) {}

    // Mark ponta visually as clickable and enable pointer events
    if (loaderTrigger) {
      loaderTrigger.classList.add('ready-to-click');
      loaderTrigger.style.pointerEvents = 'auto';
    }
    // Also make the whole connecting line clickable and show affordance
    try {
      if (loaderLine) {
        loaderLine.classList.add('ready-to-click');
        loaderLine.style.pointerEvents = 'auto';
      }
    } catch (e) {}
  }
}

function animateLoader() {
  // Animate to target percent based on loaded resources
  var targetPercent = resourcesLoaded ? 100 : Math.min(90, (loadedResources / Math.max(1, totalResources)) * 90);
  
  var interval = setInterval(function() {
    // Recalculate target in case more resources loaded
    targetPercent = resourcesLoaded ? 100 : Math.min(90, (loadedResources / Math.max(1, totalResources)) * 90);
    
    if (percent < targetPercent) {
      percent += 1;
      updateLoaderDisplay(percent);
    }
    
    if (percent >= 100 && resourcesLoaded) {
      clearInterval(interval);
      checkAllReady();
    }
  }, 25);
}

// Update the loader visuals: arrow scale, filete (line) extension and ponta visibility
function updateLoaderVisuals(percentValue) {
  var p = Math.max(0, Math.min(100, percentValue)) / 100;
  var fileteImg = document.getElementById('filete-img');
  var pontaImg = document.getElementById('ponta-img');
  if (!fileteImg || !pontaImg) return;

  // Filete (the connecting line) scales downward from 0 to nearly full based on percent
  // but starts showing after a small threshold so arrow appears first
  var fileteThreshold = 0.02; // show shortly after start
  if (p > fileteThreshold) {
    fileteImg.style.opacity = 1;
    // Map p from threshold..1 to 0..1
    var mapped = (p - fileteThreshold) / (1 - fileteThreshold);
    fileteImg.style.transform = 'scaleY(' + mapped + ')';
  } else {
    fileteImg.style.opacity = 0;
    fileteImg.style.transform = 'scaleY(0)';
  }

  // Ponta (tip) becomes visible as soon as filete starts showing and nudges slightly
  if (p > fileteThreshold) {
    pontaImg.style.opacity = 1;
    // small nudge to visually connect when near the end
    var nudge = Math.min(8, mapped * 8); // px
    pontaImg.style.transform = 'translateY(' + nudge + 'px)';
  } else {
    pontaImg.style.opacity = 0;
    pontaImg.style.transform = 'translateY(0px)';
  }
}

// Count and track all resources
function trackResources() {
  // Track images
  var images = document.querySelectorAll('img');
  totalResources += images.length;
  
  images.forEach(function(img) {
    if (img.complete) {
      loadedResources++;
    } else {
      img.addEventListener('load', function() {
        loadedResources++;
      });
      img.addEventListener('error', function() {
        loadedResources++; // Count errors too to not block forever
      });
    }
  });
  
  // Track fonts
  if (document.fonts) {
    document.fonts.ready.then(function() {
      // Fonts loaded
    });
  }
}

// Wait for everything to be ready
function waitForPageReady() {
  trackResources();
  
  // Use window.onload to ensure all resources are loaded
  if (document.readyState === 'complete') {
    // Page already loaded
    setTimeout(function() {
      resourcesLoaded = true;
    }, 500); // Small delay to ensure fonts are rendered
  } else {
    window.addEventListener('load', function() {
      // All resources loaded
      setTimeout(function() {
        resourcesLoaded = true;
      }, 500); // Small delay to ensure fonts are rendered
    });
  }
}

// Make the ponta image clickable once the loader reaches 100%
if (loaderTrigger) {
  loaderTrigger.addEventListener('click', function() {
    if (!animationComplete) return; // Wait until ready
    loader.classList.add('hidden');
    document.body.style.overflow = '';
    // Start automatic word reveal animation after loader closes
    setTimeout(startWordRevealAnimation, 600);
  });
}

// Also allow clicking the whole connecting line area to enter (same behavior as clicking ponta)
if (loaderLine) {
  loaderLine.addEventListener('click', function() {
    if (!animationComplete) return; // Wait until ready
    loader.classList.add('hidden');
    document.body.style.overflow = '';
    setTimeout(startWordRevealAnimation, 600);
  });
}

// Force scroll to top and reset state on page load/reload
window.scrollTo(0, 0);
document.body.style.overflow = 'hidden';

// Hide hamburger initially (just remove class, don't set inline style)
var hamburgerInit = document.getElementById('hamburger');
if (hamburgerInit) {
  hamburgerInit.classList.remove('visible');
}

// Hide track trace link initially
var trackTraceInit = document.getElementById('track-trace');
if (trackTraceInit) {
  trackTraceInit.classList.remove('visible');
}

// Reset panel background
var panelInit = document.getElementById('main-panel');
if (panelInit) {
  panelInit.style.background = '#111';
}

// Reset vertical line
var verticalLineInit = document.getElementById('vertical-line');
if (verticalLineInit) {
  verticalLineInit.style.opacity = '0';
}

// Reset all words to initial state
document.querySelectorAll('.word').forEach(function(word) {
  word.style.opacity = '0';
  word.style.transform = '';
  word.style.color = '#009844';
});

waitForPageReady();
animateLoader();
// On initial load, show only the ponta image for now. The arrow and filete will remain hidden
// until the percent progresses (filete shows after threshold in updateLoaderVisuals).
try {
  var pontaInit = document.getElementById('ponta-img');
  if (pontaInit) {
    pontaInit.style.opacity = 1;
    pontaInit.style.transform = 'translateY(0px)';
  }
  // No separate arrow element anymore; ponta will indicate readiness
  // Ensure filete hidden at start (updateLoaderVisuals will reveal it when appropriate)
  var fileteInit = document.getElementById('filete-img');
  if (fileteInit) {
    fileteInit.style.opacity = 0;
    fileteInit.style.transform = 'scaleY(0)';
  }
} catch (e) {
  // ignore if elements not yet available
}

var panel = document.getElementById('main-panel');
var connPath = document.getElementById('connector-path');
var txtEl = document.querySelector('.txt');
var letterIds = ['letter-1', 'letter-2', 'letter-3', 'letter-4', 'letter-5', 'letter-6'];
var dots = [];
for (var i = 0; i < 7; i++) {
  dots.push(document.getElementById('dot-' + (i + 1)));
}

// Cache for fixed path when text starts sliding
var cachedPath = null;
var cachedDotPositions = [];
var cachedExitLineLength = 0;
var cachedVerticalLineX = null;
var cachedVerticalLineStartY = null;

// Get all words for animation
var wordsFromLeft = document.querySelectorAll('.word.from-left');
var wordsFromRight = document.querySelectorAll('.word.from-right');
var textAnimationComplete = false;

// Alignment animation state
var currentAlignment = 'left'; // 'left' or 'center'

function animateTxtAlignment(target, immediate) {
  if (!txtEl) return;
  if (target === currentAlignment) return;
  // Compute current bounding rect and desired center offset
  var rect = txtEl.getBoundingClientRect();
  var panelRect = panel.getBoundingClientRect();
  var duration = immediate ? 0 : 0.55;
  var ease = 'power2.out';

  if (target === 'center') {
    var centerX = (window.innerWidth - rect.width) / 2;
    var dx = centerX - rect.left;
    gsap.to(txtEl, { x: dx, duration: duration, ease: ease, overwrite: true });
  } else {
    // Restore to natural flow (no translate)
    gsap.to(txtEl, { x: 0, duration: duration, ease: ease, overwrite: true });
  }

  currentAlignment = target;
}


// Reset state on page load/reload
function resetState() {
  wordsFromLeft.forEach(function(word) {
    word.style.opacity = 0;
    word.style.transform = 'translateX(-100vw)';
  });
  wordsFromRight.forEach(function(word) {
    word.style.opacity = 0;
    word.style.transform = 'translateX(100vw)';
  });
  connPath.style.opacity = 0;
  dots.forEach(function(dot) {
    if (dot) dot.style.opacity = 0;
  });
  textAnimationComplete = false;
}

// Reset on page load
resetState();
// Also reset if user scrolls to top
window.addEventListener('beforeunload', function() {
  window.scrollTo(0, 0);
});

// Prevent scroll function
function preventScroll(e) {
  e.preventDefault();
  e.stopPropagation();
  return false;
}

// Automatic word reveal animation
function startWordRevealAnimation() {
  var allWords = document.querySelectorAll('.word');
  var duration = 2.0; // seconds for each word (slower)
  var stagger = 0.3; // delay between words (slow)
  
  // Lock scroll during word animation - multiple methods for reliability
  document.body.style.overflow = 'hidden';
  document.body.style.position = 'fixed';
  document.body.style.width = '100%';
  document.body.style.top = '0';
  
  // Also prevent scroll events
  window.addEventListener('wheel', preventScroll, { passive: false });
  window.addEventListener('touchmove', preventScroll, { passive: false });
  
  // Animate words from left
  gsap.to(wordsFromLeft, {
    opacity: 1,
    x: 0,
    duration: duration,
    stagger: stagger,
    ease: 'power2.out'
  });
  
  // Animate words from right (slightly delayed)
  gsap.to(wordsFromRight, {
    opacity: 1,
    x: 0,
    duration: duration,
    stagger: stagger,
    ease: 'power2.out',
    delay: 0.2,
    onComplete: function() {
      textAnimationComplete = true;
      
      // Unlock scroll after animation completes
      document.body.style.overflow = '';
      document.body.style.position = '';
      document.body.style.width = '';
      document.body.style.top = '';
      
      // Remove scroll prevention
      window.removeEventListener('wheel', preventScroll);
      window.removeEventListener('touchmove', preventScroll);
      
      // Ensure we're at top and refresh ScrollTrigger
      window.scrollTo(0, 0);
      setTimeout(function() { ScrollTrigger.refresh(); }, 100);
    }
  });
}

function getLetterCenter(id) {
  var el = document.getElementById(id);
  if (!el) return null;
  var rect = el.getBoundingClientRect();
  return { x: rect.left + rect.width / 2, y: rect.top + rect.height / 2 };
}

function buildPath(exitLineLength) {
  var points = [];
  for (var i = 0; i < letterIds.length; i++) {
    var p = getLetterCenter(letterIds[i]);
    if (p) points.push(p);
  }
  if (points.length < 2) return '';
  
  // Use straight lines instead of curves
  var d = 'M ' + points[0].x + ' ' + points[0].y;
  for (var j = 1; j < points.length; j++) {
    var curr = points[j];
    d += ' L ' + curr.x + ' ' + curr.y;
  }
  
  // Add straight line down from last letter (S) - length based on scroll
  if (exitLineLength > 0 && points.length > 0) {
    var lastPoint = points[points.length - 1];
    var exitY = lastPoint.y + exitLineLength;
    d += ' L ' + lastPoint.x + ' ' + exitY;
  }
  
  return d;
}

function updateConnector(progress, exitLineLength) {
  var points = [];
  for (var i = 0; i < letterIds.length; i++) {
    var p = getLetterCenter(letterIds[i]);
    if (p) points.push(p);
  }
  if (points.length < 2) return;
  
  // Add exit point (straight down from S)
  if (exitLineLength > 0 && points.length > 0) {
    var lastPoint = points[points.length - 1];
    var exitY = lastPoint.y + exitLineLength;
    points.push({ x: lastPoint.x, y: exitY });
  }
  
  connPath.setAttribute('d', buildPath(exitLineLength));
  var len = connPath.getTotalLength();
  if (len > 0) {
    connPath.style.strokeDasharray = len;
    connPath.style.strokeDashoffset = len * (1 - progress);
    // Keep line visible once it starts drawing, and always visible at 100%
    if (progress >= 1) {
      connPath.style.opacity = 1;
    } else {
      connPath.style.opacity = progress > 0.01 ? 1 : 0;
    }
  }
  
  // Get all words that don't have connection points (will vanish)
  var allWords = document.querySelectorAll('.word');
  
  for (var idx = 0; idx < points.length; idx++) {
    var pt = points[idx];
    if (dots[idx]) {
      dots[idx].setAttribute('cx', pt.x);
      dots[idx].setAttribute('cy', pt.y);
      var dotVisible = progress >= (idx + 1) / points.length;
      dots[idx].style.opacity = dotVisible ? 0.9 : 0;
      // Toggle visibility too so the circle (and its drop-shadow) doesn't render at 0,0
      dots[idx].style.visibility = dotVisible ? 'visible' : 'hidden';
    }
    // Only try to update letter classes for the first 6 points (letters)
    if (idx < letterIds.length) {
      var letter = document.getElementById(letterIds[idx]);
      if (letter) {
        if (progress >= (idx + 1) / points.length) {
          letter.classList.add('passed');
        } else {
          letter.classList.remove('passed');
        }
      }
    }
  }
  
  // Make words with 'vanishes' class turn black as we scroll
  allWords.forEach(function(word) {
    if (word.classList.contains('vanishes')) {
      // Words that should vanish turn black instead
      var fadeStart = 0.3; // Start darkening at 30% progress
      var fadeEnd = 0.7; // Fully black at 70% progress
      if (progress < fadeStart) {
        word.style.color = '#009844'; // Original green
      } else if (progress > fadeEnd) {
        word.style.color = '#111'; // Black (matches background)
      } else {
        var fadeProgress = (progress - fadeStart) / (fadeEnd - fadeStart);
        // Interpolate from green (#009844) to black (#111)
        var r = Math.round(0 * (1 - fadeProgress) + 17 * fadeProgress);
        var g = Math.round(152 * (1 - fadeProgress) + 17 * fadeProgress);
        var b = Math.round(68 * (1 - fadeProgress) + 17 * fadeProgress);
        word.style.color = 'rgb(' + r + ',' + g + ',' + b + ')';
      }
    }
  });
}

// Rain droplets
var rainDroplets = [];
var numDroplets = 20;
var rainStarted = false;

function createRainDroplets() {
  var svg = document.getElementById('connector-svg');
  var panelRect = panel.getBoundingClientRect();
  
  for (var i = 0; i < numDroplets; i++) {
    var line = document.createElementNS('http://www.w3.org/2000/svg', 'line');
    var x = Math.random() * panelRect.width + panelRect.left;
    var startY = Math.random() * -200 - 50; // Start above the panel
    var dropLength = 30 + Math.random() * 50; // Random length
    
    line.setAttribute('x1', x);
    line.setAttribute('y1', startY);
    line.setAttribute('x2', x);
    line.setAttribute('y2', startY + dropLength);
    line.setAttribute('stroke', '#000');
    line.setAttribute('stroke-width', '2');
    line.setAttribute('class', 'rain-droplet');
    line.style.opacity = 0;
    
    svg.appendChild(line);
    rainDroplets.push({
      element: line,
      startX: x,
      startY: startY,
      length: dropLength,
      speed: 0.5 + Math.random() * 0.5, // Random speed multiplier
      delay: Math.random() * 0.5 // Random delay
    });
  }
}

function animateRainDroplets(progress) {
  // progress goes from 0 to 1 for rain animation phase
  var panelRect = panel.getBoundingClientRect();
  var endY = panelRect.height + 100;
  
  for (var i = 0; i < rainDroplets.length; i++) {
    var drop = rainDroplets[i];
    var dropProgress = Math.max(0, Math.min(1, (progress - drop.delay) / (1 - drop.delay)));
    dropProgress = dropProgress * drop.speed;
    dropProgress = Math.min(1, dropProgress);
    
    var currentY = drop.startY + (endY - drop.startY) * dropProgress;
    
    drop.element.setAttribute('y1', currentY);
    drop.element.setAttribute('y2', currentY + drop.length);
    drop.element.style.opacity = dropProgress > 0 && dropProgress < 0.95 ? 0.7 : 0;
  }
}

function slideTextOut(slideProgress) {
  // slideProgress goes from 0 to 1, controlling how far the text slides
  var allWords = document.querySelectorAll('.word');
  var maxSlide = window.innerWidth + 200; // slide off screen
  
  allWords.forEach(function(word) {
    word.style.transform = 'translateX(' + (slideProgress * maxSlide) + 'px)';
  });
  
  // Keep the cached path and dot positions fixed - don't update them
  // Just fade out the connector path and dots as text slides
  connPath.style.opacity = Math.max(0, 1 - slideProgress * 2);
  for (var i = 0; i < dots.length; i++) {
    if (dots[i]) {
      dots[i].style.opacity = Math.max(0, 0.9 - slideProgress * 2);
    }
  }
}

// Save the current path and dot positions before text starts moving
function cachePathPositions() {
  if (cachedPath) return; // Already cached
  
  var points = [];
  for (var i = 0; i < letterIds.length; i++) {
    var p = getLetterCenter(letterIds[i]);
    if (p) points.push({ x: p.x, y: p.y });
  }
  
  // Add exit point using the cached exit line length
  if (points.length > 0 && cachedExitLineLength > 0) {
    var lastPoint = points[points.length - 1];
    var exitY = lastPoint.y + cachedExitLineLength;
    points.push({ x: lastPoint.x, y: exitY });
  }
  
  cachedDotPositions = points;
  cachedPath = buildPath(cachedExitLineLength);
}

// Use cached path and positions (for when text is sliding)
function useCachedPath() {
  if (!cachedPath) return;
  
  connPath.setAttribute('d', cachedPath);
  
  // Set dots to cached positions
  for (var idx = 0; idx < cachedDotPositions.length; idx++) {
    var pt = cachedDotPositions[idx];
    if (dots[idx]) {
      dots[idx].setAttribute('cx', pt.x);
      dots[idx].setAttribute('cy', pt.y);
    }
  }
}

ScrollTrigger.create({
  trigger: panel,
  start: 'top top',
  end: '+=350%',
  pin: true,
  pinSpacing: true,
  onUpdate: function(self) {
    var progress = self.progress;
    var svg = document.getElementById('connector-svg');
    var verticalLine = document.getElementById('vertical-line');
    
    // Only animate if text animation is complete - force back to top if not
    if (!textAnimationComplete) {
      connPath.style.opacity = 0;
      verticalLine.style.opacity = 0;
      // Force scroll back to top
      if (progress > 0) {
        self.scroll(0);
      }
      return;
    }
    
  // Phase 1: Connector line through letters (0% to 20%)
  // Phase 2: Words slide right, connector follows, vertical line starts (20% to 60%)
  // Phase 3: Everything slides off, vertical line extends down (60% to 85%)
  // Phase 4: Only vertical line remains, continues down (85% to 100%)
    
  var letterPhaseEnd = 0.20;
  var slidePhaseEnd = 0.60; // extended to slow the left->right slide
  var fadeOutPhaseEnd = 0.85;
    
    // Get the last letter position for vertical line start point
    var lastLetterPos = getLetterCenter('letter-6');
    var verticalLineX = lastLetterPos ? lastLetterPos.x : window.innerWidth / 2;
    var verticalLineStartY = lastLetterPos ? lastLetterPos.y : window.innerHeight / 2;
    
    // Get hamburger bars for color transitions
    var hamburgerBars = document.querySelectorAll('.hamburger-menu .bar');
    
    // Compute connector progress across the whole connector-draw phase (0..slidePhaseEnd)
    var connectorProgress = Math.min(1, progress / slidePhaseEnd);

    if (progress <= letterPhaseEnd) {
      // Phase 1: Draw connector line through letters (progress mapped to slidePhaseEnd to avoid jumps)
      updateConnector(connectorProgress, 0);
      
      // Reset everything - full cleanup for scroll-back-up
      cachedPath = null;
      cachedDotPositions = [];
      connPath.classList.remove('glowing', 'intermittent');
      verticalLine.style.opacity = 0;
      verticalLine.style.filter = 'none';
      
    // Keep background dark
  panel.style.background = '#111';
  // Alignment is controlled by CSS; do not change `justifyContent` here.
      
      // Reset ALL words - position and opacity
      var allWords = document.querySelectorAll('.word');
      allWords.forEach(function(word) {
        word.style.transform = 'translateX(0)';
        word.style.opacity = '1';
        word.style.visibility = 'visible';
      });
      
      // Staying words stay green
      var stayingWords = document.querySelectorAll('.word.stays');
      stayingWords.forEach(function(word) {
        word.style.color = '#009844';
        word.style.opacity = '1';
      });
      
      // Vanishing words turn dark as the connector line progresses
      // Line goes through: letter-1 (LOREM row) -> letter-2,3 (SIT row) -> letter-4,5 (CONSECTETUR) -> letter-6 (ADIPISCING)
      // IPSUM should darken after line reaches letter-2 (around 17% of connector progress)
      // DOLOR and AMET should darken after line reaches letter-2,3 (around 33%)
      // ELIT should darken after line reaches letter-6 (around 100%)
      
      var vanishingWords = document.querySelectorAll('.word.vanishes');
      vanishingWords.forEach(function(word) {
        var wordText = word.textContent;
        var darkProgress = 0;
        
        if (wordText === 'IPSUM') {
          // Darkens after line passes letter-1 to letter-2 (17% to 33%)
          if (connectorProgress > 0.17) {
            darkProgress = Math.min(1, (connectorProgress - 0.17) / 0.16);
          }
        } else if (wordText === 'DOLOR' || wordText === 'AMET') {
          // Darkens after line passes letter-2,3 (33% to 50%)
          if (connectorProgress > 0.33) {
            darkProgress = Math.min(1, (connectorProgress - 0.33) / 0.17);
          }
        } else if (wordText === 'ELIT') {
          // Darkens after line passes letter-5 to letter-6 (83% to 100%)
          if (connectorProgress > 0.83) {
            darkProgress = Math.min(1, (connectorProgress - 0.83) / 0.17);
          }
        }
        
        // Interpolate from green (#009844) to dark (#111)
        var r = Math.round(0 * (1 - darkProgress) + 17 * darkProgress);
        var g = Math.round(152 * (1 - darkProgress) + 17 * darkProgress);
        var b = Math.round(68 * (1 - darkProgress) + 17 * darkProgress);
        word.style.color = 'rgb(' + r + ',' + g + ',' + b + ')';
      });
      
      // Hide dots for vertical line
      if (dots[6]) dots[6].style.opacity = 0;
      
      // Hide hamburger and reset its color
      var hamburger = document.getElementById('hamburger');
      hamburger.classList.remove('visible');
      hamburgerBars.forEach(function(bar) {
        bar.style.background = 'white';
      });
      var hamburgerImg = document.getElementById('hamburger-img');
      if (hamburgerImg) hamburgerImg.style.filter = 'brightness(0) invert(1)';
      
      // Reset vertical line dash pattern
      verticalLine.style.strokeDasharray = 'none';
      verticalLine.style.strokeDashoffset = '0';
      
      // Reset cached positions
      cachedVerticalLineX = null;
      cachedVerticalLineStartY = null;
      
    } else if (progress <= slidePhaseEnd) {
      // Phase 2: Words + connector slide right, vertical line appears
      var slideProgress = (progress - letterPhaseEnd) / (slidePhaseEnd - letterPhaseEnd);
      // Smoothly center the text container during the slide phase
      animateTxtAlignment('center');
      
      // Cache the vertical line start position before sliding
      if (!cachedVerticalLineX) {
        cachedVerticalLineX = verticalLineX;
        cachedVerticalLineStartY = verticalLineStartY;
      }
      
      // Update connector progress so letters/dots update, but DO NOT move the main text yet.
      // The main text will only slide when the vertical line starts extending down (Phase 3).
      updateConnector(connectorProgress, 0);
      
      // Vanishing words are already dark from Phase 1 - keep them dark
      var vanishingWords = document.querySelectorAll('.word.vanishes');
      vanishingWords.forEach(function(word) {
        word.style.color = '#111';
      });
      
  // Keep connector glowing; fade it out as words slide
  connPath.classList.add('glowing');
  // Fade out connector line based on slideProgress
  connPath.style.opacity = Math.max(0, 1 - slideProgress);
      
      // Fade out dots at the same time
      dots.forEach(function(dot) {
        if (dot) dot.style.opacity = Math.max(0, 0.9 - slideProgress);
      });
      
      // Draw vertical line starting from last letter position going down
      var lastLetterPos = getLetterCenter('letter-6');
      var startX = lastLetterPos ? lastLetterPos.x : window.innerWidth / 2;
      var startY = lastLetterPos ? lastLetterPos.y : window.innerHeight / 2;
      var verticalLineLength = slideProgress * window.innerHeight * 0.5;
      verticalLine.setAttribute('x1', startX);
      verticalLine.setAttribute('y1', startY);
      verticalLine.setAttribute('x2', startX);
      verticalLine.setAttribute('y2', startY + verticalLineLength);
      verticalLine.style.opacity = slideProgress > 0.1 ? 1 : 0;
      
      // Solid line - no dashes
      verticalLine.style.strokeDasharray = 'none';
      verticalLine.style.strokeDashoffset = 0;
      
      // Keep background dark in this phase - no gradient yet
      panel.style.background = '#111';
      
    } else if (progress <= fadeOutPhaseEnd) {
      // Phase 3: Line extends DOWN, then also UP from top
  var fadeProgress = (progress - slidePhaseEnd) / (fadeOutPhaseEnd - slidePhaseEnd);
  // Restore left alignment smoothly after the slide phase completes
  animateTxtAlignment('left');
      
      // Continue sliding words off screen
      var slideAmount = (window.innerWidth * 0.5) + fadeProgress * (window.innerWidth * 0.8);
      var allWords = document.querySelectorAll('.word');
      allWords.forEach(function(word) {
        word.style.transform = 'translateX(' + slideAmount + 'px)';
      });
      
      // Connector line and dots already faded in Phase 2, keep them hidden
      connPath.style.opacity = 0;
      dots.forEach(function(dot) {
        if (dot) dot.style.opacity = 0;
      });
      
      // Line starts from last letter position (or center if not available)
      var lastLetterPos = getLetterCenter('letter-6');
      var centerX = lastLetterPos ? lastLetterPos.x : window.innerWidth / 2;
      var centerY = lastLetterPos ? lastLetterPos.y : window.innerHeight / 2;
      
      // Line extends DOWN from last letter
      var verticalLineLength = (window.innerHeight * 0.5) + fadeProgress * (window.innerHeight * 1.5);
      var lineBottomY = centerY + verticalLineLength;
      
      // After 50% progress, line ALSO extends UP from top of screen
      var lineTopY = centerY;
      if (fadeProgress > 0.5) {
        var upProgress = (fadeProgress - 0.5) / 0.5; // 0 to 1 over second half
        // Line top moves up toward top of screen
        lineTopY = centerY - (upProgress * (centerY + 50));
      }
      
      verticalLine.setAttribute('x1', centerX);
      verticalLine.setAttribute('y1', lineTopY);
      verticalLine.setAttribute('x2', centerX);
      verticalLine.setAttribute('y2', lineBottomY);
      
      // Solid line - no dashes
      verticalLine.style.strokeDasharray = 'none';
      verticalLine.style.strokeDashoffset = 0;
      
      verticalLine.style.opacity = 1;
      
      // Add glow to vertical line
      verticalLine.style.filter = 'drop-shadow(0 0 4px rgba(255, 255, 255, 0.6)) drop-shadow(0 0 8px rgba(0, 152, 68, 0.8))';
      
      // Keep hamburger hidden in this phase
      var hamburger = document.getElementById('hamburger');
      hamburger.classList.remove('visible');
      
      // Keep background BLACK throughout this entire phase
      panel.style.background = '#111';
      
    } else {
      // Phase 4: Line covers top to bottom, gradient rises and covers the line from bottom
      // Line stays vertical in the center, ending at hamburger position
      var finalProgress = (progress - fadeOutPhaseEnd) / (1 - fadeOutPhaseEnd);
      
      // Hide words completely
      var allWords = document.querySelectorAll('.word');
      allWords.forEach(function(word) {
        word.style.opacity = 0;
      });
      
      // Hide connector completely
      connPath.style.opacity = 0;
      dots.forEach(function(dot) {
        if (dot) dot.style.opacity = 0;
      });
      
      // Background radial gradient fills from bottom - from 0% to 100%
      var greenHeight = finalProgress * 110; // Green covers from 0% to 110% (full)
      if (greenHeight >= 100) {
        // Full green background
        panel.style.background = '#009844';
      } else {
        panel.style.background = 'radial-gradient(ellipse 200% 100% at 50% 120%, #009844 0%, #009844 ' + (greenHeight + 10) + '%, #004d25 ' + (greenHeight + 20) + '%, #111 ' + Math.min(100, greenHeight + 50) + '%)';
      }
      
      // Line stays vertical in the CENTER of the screen
      var centerX = window.innerWidth / 2;
      var lineTopY = -50; // Above screen
      // Line bottom is at center of screen (where hamburger is) - gradient covers from below
      var hamburgerY = window.innerHeight / 2;
      var gradientCoverY = window.innerHeight - (finalProgress * window.innerHeight);
      // Line ends at hamburger position or where gradient covers it
      var lineBottomY = Math.max(gradientCoverY, hamburgerY);
      
      // Keep line vertical at center
      verticalLine.setAttribute('x1', centerX);
      verticalLine.setAttribute('y1', lineTopY);
      verticalLine.setAttribute('x2', centerX);
      verticalLine.setAttribute('y2', lineBottomY);
      
      // Solid line - no dashes
      verticalLine.style.strokeDasharray = 'none';
      verticalLine.style.strokeDashoffset = 0;
      
      // Line stays visible until it's fully covered
      var lineOpacity = finalProgress >= 1 ? 0 : 1;
      verticalLine.style.opacity = lineOpacity;
      
      // Glow effect
      verticalLine.style.filter = 'drop-shadow(0 0 4px rgba(255, 255, 255, 0.6)) drop-shadow(0 0 8px rgba(0, 152, 68, 0.8))';
      
      // Hamburger only appears when gradient is 100% complete
      var hamburger = document.getElementById('hamburger');
      var hamburgerBars = document.querySelectorAll('.hamburger-menu .bar');
      var trackTrace = document.getElementById('track-trace');
      
      if (greenHeight >= 100) {
        // Gradient complete - show hamburger (black) and track trace link
        hamburger.classList.add('visible');
        trackTrace.classList.add('visible');
        hamburgerBars.forEach(function(bar) {
          bar.style.background = '#111';
        });
        var hamburgerImg = document.getElementById('hamburger-img');
        if (hamburgerImg) hamburgerImg.style.filter = 'brightness(0)';
      } else {
        // Gradient not complete - hide hamburger and track trace link
        hamburger.classList.remove('visible');
        trackTrace.classList.remove('visible');
      }
    }
  },
  onLeave: function() {
    // Cleanup when leaving - ensure hamburger is black and line is hidden
    var verticalLine = document.getElementById('vertical-line');
    verticalLine.style.opacity = 0;
    var hamburger = document.getElementById('hamburger');
    hamburger.classList.add('visible');
    var trackTrace = document.getElementById('track-trace');
    trackTrace.classList.add('visible');
    var hamburgerBars = document.querySelectorAll('.hamburger-menu .bar');
    hamburgerBars.forEach(function(bar) {
      bar.style.background = '#111';
    });
    var hamburgerImg = document.getElementById('hamburger-img');
    if (hamburgerImg) hamburgerImg.style.filter = 'brightness(0)';
  },
  onLeaveBack: function() {
    // Reset everything when scrolling back up past the trigger
    cachedVerticalLineX = null;
    cachedVerticalLineStartY = null;
    cachedPath = null;
    cachedDotPositions = [];
    panel.style.background = '#111';
    
    // Hide hamburger and track trace link
    var hamburger = document.getElementById('hamburger');
    hamburger.classList.remove('visible');
    var trackTrace = document.getElementById('track-trace');
    trackTrace.classList.remove('visible');
    
    // Reset hamburger bars color
    var hamburgerBars = document.querySelectorAll('.hamburger-menu .bar');
    hamburgerBars.forEach(function(bar) {
      bar.style.background = 'white';
    });
    var hamburgerImg = document.getElementById('hamburger-img');
    if (hamburgerImg) hamburgerImg.style.filter = 'brightness(0) invert(1)';
    
    // Reset vertical line
    var verticalLine = document.getElementById('vertical-line');
    verticalLine.style.opacity = 0;
    verticalLine.style.strokeDasharray = 'none';
    verticalLine.style.strokeDashoffset = '0';
    verticalLine.style.filter = 'none';
    
    // Reset ALL words - position, opacity, and color
    var allWords = document.querySelectorAll('.word');
    allWords.forEach(function(word) {
      word.style.transform = 'translateX(0)';
      word.style.opacity = '1';
      word.style.color = '#009844';
      word.style.visibility = 'visible';
    });
    
    // Reset connector
    connPath.style.opacity = 0;
    connPath.classList.remove('glowing', 'intermittent');
    
    // Reset all dots
    dots.forEach(function(dot) {
      if (dot) dot.style.opacity = 0;
    });
    // Reset text container alignment transform immediately
    animateTxtAlignment('left', true);
  }
});

window.addEventListener('resize', function() { ScrollTrigger.refresh(); });
// On resize, recompute alignment target immediately to avoid jumps
window.addEventListener('resize', function() {
  // Refresh ScrollTrigger and reposition txt for current alignment
  ScrollTrigger.refresh();
  // Re-apply alignment without animation for clean layout
  animateTxtAlignment(currentAlignment, true);
});

// Comprehensive reset on page load
window.addEventListener('load', function() { 
  // Force scroll to top
  window.scrollTo(0, 0);
  
  // Reset hamburger (just remove class, don't set inline opacity)
  var hamburger = document.getElementById('hamburger');
  hamburger.classList.remove('visible');
  
  // Reset panel background
  panel.style.background = '#111';
  
  // Reset vertical line
  var verticalLine = document.getElementById('vertical-line');
  if (verticalLine) {
    verticalLine.style.opacity = '0';
  }
  
  setTimeout(function() { 
    ScrollTrigger.refresh(); 
    updateConnector(0); 
  }, 500); 
});

// Hamburger menu click handler - reload page
var hamburgerMenu = document.getElementById('hamburger');

hamburgerMenu.addEventListener('click', function() {
  location.reload();
});

// Idle scroll indicator
var scrollIndicator = document.getElementById('scroll-indicator');
var idleTimeout;
var idleDelay = 3000; // Show after 3 seconds of no scrolling

function showScrollIndicator() {
  // Only show if not at the end (hamburger not visible) and loader is hidden
  var hamburger = document.getElementById('hamburger');
  var loaderHidden = loader.classList.contains('hidden');
  if (loaderHidden && !hamburger.classList.contains('visible')) {
    scrollIndicator.classList.add('visible');
  }
}

function hideScrollIndicator() {
  scrollIndicator.classList.remove('visible');
}

function resetIdleTimer() {
  hideScrollIndicator();
  clearTimeout(idleTimeout);
  idleTimeout = setTimeout(showScrollIndicator, idleDelay);
}

// Listen for scroll events
window.addEventListener('scroll', resetIdleTimer);
window.addEventListener('mousemove', resetIdleTimer);
window.addEventListener('touchstart', resetIdleTimer);

// Start the idle timer after page loads
window.addEventListener('load', function() {
  setTimeout(resetIdleTimer, 1000);
});

// Scroll to top before page unloads (helps with reload/back button)
window.addEventListener('beforeunload', function() {
  window.scrollTo(0, 0);
});

// Also handle page show for back/forward cache (important for mobile Safari)
window.addEventListener('pageshow', function(event) {
  // Always reset scroll position
  window.scrollTo(0, 0);
  
  if (event.persisted) {
    // Page was restored from back/forward cache - force full reload
    location.reload();
  } else {
    // Normal page load on mobile - ensure reset
    var hamburger = document.getElementById('hamburger');
    if (hamburger) hamburger.classList.remove('visible');
    
    var trackTrace = document.getElementById('track-trace');
    if (trackTrace) trackTrace.classList.remove('visible');
    
    var panel = document.getElementById('main-panel');
    if (panel) panel.style.background = '#111';
    
    var verticalLine = document.getElementById('vertical-line');
    if (verticalLine) verticalLine.style.opacity = '0';
  }
});

// For iOS Safari - handle visibility change
document.addEventListener('visibilitychange', function() {
  if (document.visibilityState === 'visible') {
    // User came back to the page - check if we need to reset
    var hamburger = document.getElementById('hamburger');
    var loader = document.getElementById('loader');
    
    // If hamburger is visible but loader is not hidden, something is wrong - reload
    if (hamburger && hamburger.classList.contains('visible') && loader && !loader.classList.contains('hidden')) {
      location.reload();
    }
  }
});

// Make all images non-draggable and prevent dragstart so images cannot be selected or dragged
document.addEventListener('DOMContentLoaded', function() {
  document.querySelectorAll('img').forEach(function(img) {
    try {
      img.setAttribute('draggable', 'false');
      img.style.webkitUserDrag = 'none';
      img.style.userSelect = 'none';
      img.style.webkitTouchCallout = 'none';
      img.addEventListener('dragstart', function(e) { e.preventDefault(); });
    } catch (e) {
      // ignore
    }
  });
  // Prevent any element from being dragged or selected at the document level
  document.addEventListener('dragstart', function(e) { e.preventDefault(); });
  document.addEventListener('selectstart', function(e) { e.preventDefault(); });
});
</script>

</body>
</html>
