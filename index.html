<!DOCTYPE html>
<html>
<head>
<meta charset="UTF-8">
<title>LUGATANI</title>

<script src="https://cdnjs.cloudflare.com/ajax/libs/gsap/3.12.2/gsap.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/gsap/3.12.2/ScrollTrigger.min.js"></script>

<link rel="stylesheet" href="testload.css">
<style>
#loader {
  position: fixed;
  z-index: 9999;
  inset: 0;
  background: #111;
  display: flex;
  align-items: center;
  justify-content: center;
  transition: opacity 0.8s ease;
}

#loader-content {
  display: flex;
  flex-direction: column;
  align-items: center;
  gap: 40px;
  text-align: center;
}

#loader-text {
  font-size: 3rem;
  font-weight: 300;
  color: white;
  letter-spacing: 3px;
  min-width: 140px;
  font-family: 'Helvetica Neue', 'Montserrat', sans-serif;
}

#loader-arrow {
  opacity: 0;
  cursor: pointer;
  transition: opacity 0.6s ease, transform 0.4s ease;
  transform: translateY(20px);
  display: flex;
  align-items: center;
  justify-content: center;
}

#loader-arrow svg {
  filter: drop-shadow(0 0 4px rgba(255,255,255,0.4));
  transition: transform 0.3s ease, filter 0.3s ease;
}

#loader-arrow:hover svg {
  transform: translateY(-8px);
  filter: drop-shadow(0 0 8px rgba(126, 227, 183, 0.8));
}

#loader-arrow:hover svg line {
  stroke: #7ee3b7;
  transition: stroke 0.3s ease;
}

@media (max-width: 600px) {
  #loader-text {
    font-size: 2.2rem;
  }
  
  #loader-arrow svg {
    width: 60px;
    height: 90px;
  }
}
</style>
</head>
<body>

<!-- LOADING SCREEN -->
<div id="loader">
  <div id="loader-content">
    <div id="loader-text">0%</div>
    <div id="loader-arrow">
      <svg width="60" height="100" viewBox="0 0 60 100" fill="none" xmlns="http://www.w3.org/2000/svg">
        <!-- Main arrow line going down -->
        <line x1="30" y1="10" x2="30" y2="75" stroke="white" stroke-width="1.2" stroke-linecap="round"/>
        <!-- Left arrow point -->
        <line x1="30" y1="75" x2="18" y2="62" stroke="white" stroke-width="1.2" stroke-linecap="round" stroke-linejoin="round"/>
        <!-- Right arrow point -->
        <line x1="30" y1="75" x2="42" y2="62" stroke="white" stroke-width="1.2" stroke-linecap="round" stroke-linejoin="round"/>
      </svg>
    </div>
  </div>
</div>

<div class="panel" id="p1">
  <div class="txt">
    <div class="line"><span class="part from-left">LOREM</span><span class="part">IPSUM</span></div>
    <div class="line"><span class="part from-left">DOLOR</span><span class="part">SIT</span><span class="part">AMET</span></div>
    <div class="line"><span class="part from-left">lisboa</span><span class="part">atenas</span><span class="part">1999</span></div>
  </div>
</div>

<div class="panel" id="p2">
  <div class="txt">
    <div class="line"><span class="part from-left">CONSECTETUR</span></div>
    <div class="line"><span class="part from-left">ADIPISCING</span><span class="part">ELIT</span></div>
    <div class="line"><span class="part from-left">LATIN</span><span class="part">YES</span></div>
  </div>
</div>

<div class="panel" id="p3">
  <div class="txt">
    <div class="line"><span class="part from-left">SLIDE</span><span class="part">THREE</span></div>
    <div class="line"><span class="part from-left">ANIMATED</span><span class="part">TEXT</span></div>
    <div class="line"><span class="part from-right">AN0THER</span><span class="part">DAY</span></div>

</div>
</div>

<script>
gsap.registerPlugin(ScrollTrigger);

const allPaths = [];

function createConnectors(panel) {
  const old = panel.querySelectorAll("svg.connector-line");
  old.forEach(o => o.remove());

  const parts = Array.from(panel.querySelectorAll(".part"));
  if (parts.length < 2) return;

  const svg = document.createElementNS("http://www.w3.org/2000/svg", "svg");
  svg.classList.add("connector-line");
  svg.style.cssText = "position:absolute;top:0;left:0;width:100%;height:100%;pointer-events:none;z-index:5;";
  panel.style.position = "relative";
  panel.insertBefore(svg, panel.firstChild);

  const path = document.createElementNS("http://www.w3.org/2000/svg", "path");
  path.setAttribute("fill", "none");
  path.setAttribute("stroke", "white");
  path.setAttribute("stroke-width", "1");
  path.style.opacity = "0";
  svg.appendChild(path);

  // Create dots for each connection point
  const dots = parts.map((part, idx) => {
    const dot = document.createElementNS("http://www.w3.org/2000/svg", "circle");
    dot.setAttribute("r", "4");
    dot.setAttribute("fill", "white");
    dot.style.opacity = "0";
    dot.style.filter = "drop-shadow(0 0 6px rgba(126, 227, 183, 0.8))";
    dot.classList.add("connection-dot");
    svg.appendChild(dot);
    return dot;
  });

  allPaths.push({ panel, svg, path, parts, dots, animated: false });

  requestAnimationFrame(positionAllPaths);

  return { svg, path, dots };
}

function positionAllPaths() {
  allPaths.forEach(entry => {
    const { svg, path, parts, dots } = entry;
    if (!parts || parts.length < 2) return;

    const svgRect = svg.getBoundingClientRect();

    // Build a list of center points for each word
    const wordCenters = parts.map(p => {
        const r = p.getBoundingClientRect();
        return {
            x: (r.left + r.right) / 2 - svgRect.left,
            y: (r.top + r.bottom) / 2 - svgRect.top
        };
    });

    // Path passes exactly through the center of each word
    const pts = wordCenters;

    const d = bezierFromPoints(pts);
    path.setAttribute("d", d);

    // Position dots at each connection point
    if (dots) {
      dots.forEach((dot, idx) => {
        dot.setAttribute("cx", pts[idx].x);
        dot.setAttribute("cy", pts[idx].y);
      });
    }

    const len = path.getTotalLength();
    path.style.strokeDasharray = len;

    if (!entry.animated) {
      path.style.strokeDashoffset = len;
      path.style.opacity = 0;
    }
  });
}

// FIXED — TRUE Catmull-Rom → Bézier converter
function bezierFromPoints(pts, tension = 0.5) {
  if (pts.length < 2) return "";
  let d = `M ${pts[0].x} ${pts[0].y}`;
  for (let i = 0; i < pts.length - 1; i++) {
    const p0 = pts[i - 1] || pts[i];
    const p1 = pts[i];
    const p2 = pts[i + 1];
    const p3 = pts[i + 2] || p2;

    const cp1 = {
      x: p1.x + (p2.x - p0.x) * tension / 6,
      y: p1.y + (p2.y - p0.y) * tension / 6
    };
    const cp2 = {
      x: p2.x - (p3.x - p1.x) * tension / 6,
      y: p2.y - (p3.y - p1.y) * tension / 6
    };

    d += ` C ${cp1.x} ${cp1.y}, ${cp2.x} ${cp2.y}, ${p2.x} ${p2.y}`;
  }
  return d;
}

// Reposition on resize
window.addEventListener("resize", () => {
  clearTimeout(window._r);
  window._r = setTimeout(positionAllPaths, 80);
});

ScrollTrigger.addEventListener("refresh", positionAllPaths);

// Detect if mobile
const isMobile = window.innerWidth < 768;

// Animation parameters that adapt to screen size
const animConfig = {
  slideDistance: isMobile ? 80 : 150,
  duration: isMobile ? 0.6 : 1,
  stagger: isMobile ? 0.04 : 0.07,
  pathDuration: isMobile ? 0.6 : 1
};

// Create connectors + animate text + animate path
document.querySelectorAll(".panel").forEach(panel => {
  const parts = panel.querySelectorAll(".part");
  const conn = createConnectors(panel);

  gsap.fromTo(parts,
    { opacity: 0, x: i => parts[i].classList.contains("from-left") ? -animConfig.slideDistance : animConfig.slideDistance },
    {
      opacity: 1,
      x: 0,
      duration: animConfig.duration,
      stagger: animConfig.stagger,
      ease: "power3.out",
      scrollTrigger: {
        trigger: panel,
        start: "top center",
        end: "bottom center",
        onEnter: () => {
          gsap.to(parts, {
            opacity: 1,
            x: 0,
            duration: animConfig.duration * 0.8,
            stagger: animConfig.stagger,
            ease: "power3.out"
          });
        },
        onLeave: () => {
          gsap.to(parts, {
            opacity: 0,
            x: i => parts[i].classList.contains("from-left") ? -animConfig.slideDistance : animConfig.slideDistance,
            duration: animConfig.duration * 0.8,
            stagger: animConfig.stagger * 0.7,
            ease: "power3.in"
          });
        },
        onEnterBack: () => {
          gsap.to(parts, {
            opacity: 1,
            x: 0,
            duration: animConfig.duration * 0.8,
            stagger: animConfig.stagger * 0.7,
            ease: "power3.out"
          });
        },
        onLeaveBack: () => {
          gsap.to(parts, {
            opacity: 0,
            x: i => parts[i].classList.contains("from-left") ? -animConfig.slideDistance : animConfig.slideDistance,
            duration: animConfig.duration * 0.8,
            stagger: animConfig.stagger * 0.7,
            ease: "power3.in"
          });
        }
      }
    }
  );

  if (conn) {
    const path = conn.path;
    const dots = conn.dots;
    ScrollTrigger.create({
      trigger: panel,
      start: "top center",
      onEnter: () => {
        const len = path.getTotalLength();
        gsap.to(path, {
          strokeDashoffset: 0,
          opacity: 1,
          duration: animConfig.pathDuration,
          ease: "power3.out"
        });

        // Animate dots to flash in with a staggered delay
        if (dots) {
          dots.forEach((dot, idx) => {
            gsap.fromTo(dot,
              { opacity: 0, r: 2 },
              {
                opacity: 1,
                r: isMobile ? 3 : 4,
                duration: animConfig.pathDuration * 0.6,
                delay: (animConfig.pathDuration * 0.3) + (idx * (isMobile ? 0.06 : 0.1)),
                ease: "back.out"
              }
            );

            // Add pulsing animation to dots
            gsap.to(dot, {
              opacity: 0.6,
              r: isMobile ? 4 : 5,
              duration: 0.8,
              delay: (animConfig.pathDuration * 0.3) + (idx * (isMobile ? 0.06 : 0.1)),
              yoyo: true,
              repeat: -1,
              ease: "sine.inOut"
            });
          });
        }
      },
      onLeave: () => {
        const len = path.getTotalLength();
        gsap.to(path, {
          strokeDashoffset: len,
          opacity: 0,
          duration: animConfig.pathDuration * 0.8,
          ease: "power3.in"
        });

        // Animate dots to fade out
        if (dots) {
          dots.forEach((dot, idx) => {
            gsap.to(dot, {
              opacity: 0,
              r: 2,
              duration: animConfig.pathDuration * 0.6,
              delay: idx * (isMobile ? 0.03 : 0.05),
              ease: "back.in"
            });
          });
        }
      },
      onEnterBack: () => {
        const len = path.getTotalLength();
        gsap.to(path, {
          strokeDashoffset: 0,
          opacity: 1,
          duration: animConfig.pathDuration * 0.8,
          ease: "power3.out"
        });

        // Animate dots to fade back in
        if (dots) {
          dots.forEach((dot, idx) => {
            gsap.to(dot, {
              opacity: 1,
              r: isMobile ? 3 : 4,
              duration: animConfig.pathDuration * 0.6,
              delay: idx * (isMobile ? 0.03 : 0.05),
              ease: "back.out"
            });
          });
        }
      },
      onLeaveBack: () => {
        const len = path.getTotalLength();
        gsap.to(path, {
          strokeDashoffset: len,
          opacity: 0,
          duration: animConfig.pathDuration * 0.8,
          ease: "power3.in"
        });

        // Animate dots to fade out
        if (dots) {
          dots.forEach((dot, idx) => {
            gsap.to(dot, {
              opacity: 0,
              r: 2,
              duration: animConfig.pathDuration * 0.6,
              delay: idx * (isMobile ? 0.03 : 0.05),
              ease: "back.in"
            });
          });
        }
      }
    });
  }
});

const loader = document.getElementById("loader");
const loaderText = document.getElementById("loader-text");
const loaderArrow = document.getElementById("loader-arrow");

let current = 0;
let target = 0;

// Update % counter
const counter = setInterval(() => {
  if (current < target) {
    current++;
    loaderText.textContent = current + "%";
  }

  // When it hits 100%, reveal arrow
  if (current === 100) {
    loaderArrow.style.opacity = "1";
    loaderArrow.style.transform = "translateY(0px)";
  }
}, 20);

// When page is fully loaded
window.addEventListener("load", () => {
  target = 100;

  // User clicks arrow to enter
  loaderArrow.addEventListener("click", () => {
    loader.style.transition = "opacity 0.8s ease";
    loader.style.opacity = "0";
    setTimeout(() => loader.remove(), 900);
  });
});

// Simulate loading until ready
(function simulateProgress() {
  const simulate = setInterval(() => {
    if (target < 90) {
      target += Math.random() * 5;
      if (target > 90) target = 90;
    }
  }, 100);
})();
</script>


</body>
</html>
