<!DOCTYPE html>
<html>
<head>
<meta charset="UTF-8">
<title>LUGATANI - Connection Point Builder</title>

<script src="https://cdnjs.cloudflare.com/ajax/libs/gsap/3.12.2/gsap.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/gsap/3.12.2/ScrollTrigger.min.js"></script>

<style>
  * {
    margin: 0;
    padding: 0;
    box-sizing: border-box;
  }

  body {
    background: #1a1a1a;
    font-family: 'Segoe UI', Montserrat, sans-serif;
    color: white;
    min-height: 100vh;
  }

  /* BUILDER UI */
  .builder-container {
    display: flex;
    height: 100vh;
  }

  .sidebar {
    width: 350px;
    background: #222;
    padding: 20px;
    overflow-y: auto;
    border-right: 1px solid #333;
  }

  .preview-area {
    flex: 1;
    display: flex;
    flex-direction: column;
  }

  .preview-controls {
    padding: 15px 20px;
    background: #252525;
    border-bottom: 1px solid #333;
    display: flex;
    gap: 15px;
    align-items: center;
  }

  .preview-panel {
    flex: 1;
    display: flex;
    align-items: center;
    justify-content: center;
    background: #111;
    position: relative;
    overflow: hidden;
  }

  h1 {
    font-size: 1.4rem;
    margin-bottom: 20px;
    color: #00c853;
  }

  h2 {
    font-size: 1rem;
    margin: 20px 0 10px;
    color: #888;
    text-transform: uppercase;
    letter-spacing: 1px;
  }

  /* Form elements */
  textarea {
    width: 100%;
    height: 150px;
    background: #333;
    border: 1px solid #444;
    border-radius: 8px;
    padding: 12px;
    color: white;
    font-family: monospace;
    font-size: 14px;
    resize: vertical;
  }

  textarea:focus {
    outline: none;
    border-color: #00c853;
  }

  .btn {
    padding: 10px 20px;
    border: none;
    border-radius: 6px;
    cursor: pointer;
    font-size: 14px;
    font-weight: 600;
    transition: all 0.2s;
  }

  .btn-primary {
    background: #00c853;
    color: #111;
  }

  .btn-primary:hover {
    background: #00e676;
  }

  .btn-secondary {
    background: #444;
    color: white;
  }

  .btn-secondary:hover {
    background: #555;
  }

  .btn-export {
    background: #2196f3;
    color: white;
  }

  .btn-export:hover {
    background: #42a5f5;
  }

  /* Instructions */
  .instructions {
    background: #2a2a2a;
    padding: 15px;
    border-radius: 8px;
    margin-bottom: 20px;
    font-size: 13px;
    line-height: 1.6;
    color: #aaa;
  }

  .instructions strong {
    color: #00c853;
  }

  /* Connection points list */
  .points-list {
    margin-top: 15px;
  }

  .point-item {
    display: flex;
    align-items: center;
    justify-content: space-between;
    padding: 8px 12px;
    background: #333;
    border-radius: 6px;
    margin-bottom: 8px;
    font-size: 14px;
  }

  .point-item span {
    color: #00c853;
    font-weight: bold;
  }

  .point-item button {
    background: #c62828;
    border: none;
    color: white;
    padding: 4px 10px;
    border-radius: 4px;
    cursor: pointer;
    font-size: 12px;
  }

  .point-item button:hover {
    background: #e53935;
  }

  /* Preview text styling */
  .preview-txt {
    text-align: left;
    line-height: 0.95;
  }

  .preview-line {
    font-size: clamp(30px, 8vw, 90px);
    font-weight: 800;
    color: #009844;
    transform: skewX(-10deg);
    white-space: nowrap;
    display: flex;
    align-items: center;
    gap: 15px;
    margin-bottom: 5px;
  }

  .preview-word {
    display: inline-block;
    position: relative;
  }

  .preview-letter {
    display: inline-block;
    cursor: pointer;
    transition: all 0.2s;
    position: relative;
  }

  .preview-letter:hover {
    color: #00e676;
    text-shadow: 0 0 10px rgba(0, 200, 83, 0.5);
  }

  .preview-letter.selected {
    color: #00e676;
    text-shadow: 0 0 15px rgba(0, 200, 83, 0.8);
  }

  .preview-letter.selected::after {
    content: attr(data-index);
    position: absolute;
    top: -20px;
    left: 50%;
    transform: translateX(-50%);
    background: #00c853;
    color: #111;
    font-size: 12px;
    padding: 2px 6px;
    border-radius: 10px;
    font-weight: bold;
  }

  /* SVG connector in preview */
  svg.preview-connector {
    position: absolute;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
    pointer-events: none;
    z-index: 50;
  }

  svg.preview-connector path {
    stroke: white;
    stroke-width: 2px;
    stroke-linecap: round;
    stroke-linejoin: round;
    fill: none;
  }

  svg.preview-connector circle {
    fill: white;
    filter: drop-shadow(0 0 8px rgba(126, 227, 183, 0.9));
  }

  /* Progress slider */
  .progress-control {
    display: flex;
    align-items: center;
    gap: 10px;
    flex: 1;
  }

  .progress-control label {
    font-size: 13px;
    color: #888;
  }

  .progress-control input[type="range"] {
    flex: 1;
    height: 6px;
    -webkit-appearance: none;
    background: #444;
    border-radius: 3px;
    outline: none;
  }

  .progress-control input[type="range"]::-webkit-slider-thumb {
    -webkit-appearance: none;
    width: 16px;
    height: 16px;
    background: #00c853;
    border-radius: 50%;
    cursor: pointer;
  }

  .progress-value {
    font-size: 13px;
    color: #00c853;
    min-width: 40px;
  }

  /* Export modal */
  .modal {
    display: none;
    position: fixed;
    inset: 0;
    background: rgba(0,0,0,0.8);
    z-index: 1000;
    align-items: center;
    justify-content: center;
  }

  .modal.active {
    display: flex;
  }

  .modal-content {
    background: #222;
    padding: 30px;
    border-radius: 12px;
    max-width: 800px;
    width: 90%;
    max-height: 80vh;
    overflow-y: auto;
  }

  .modal-content h2 {
    color: #00c853;
    margin-bottom: 15px;
  }

  .modal-content pre {
    background: #111;
    padding: 15px;
    border-radius: 8px;
    overflow-x: auto;
    font-size: 12px;
    color: #aaa;
  }

  .modal-content .close-btn {
    margin-top: 20px;
  }

  /* Empty state */
  .empty-state {
    color: #555;
    font-size: 1.2rem;
    text-align: center;
  }
</style>
</head>
<body>

<div class="builder-container">
  <!-- Sidebar -->
  <div class="sidebar">
    <h1>üîó Connection Builder</h1>
    
    <div class="instructions">
      <strong>How to use:</strong><br>
      1. Enter your text below (one line per row)<br>
      2. Separate words with spaces<br>
      3. Click "Generate Preview"<br>
      4. Click on letters to select connection points<br>
      5. Adjust the progress slider to preview animation<br>
      6. Click "Export Code" when done
    </div>

    <h2>Enter Text</h2>
    <textarea id="text-input" placeholder="LOREM IPSUM
DOLOR SIT AMET
CONSECTETUR
ADIPISCING ELIT">LOREM IPSUM
DOLOR SIT AMET
CONSECTETUR
ADIPISCING ELIT</textarea>

    <div style="margin-top: 15px;">
      <button class="btn btn-primary" onclick="generatePreview()">Generate Preview</button>
      <button class="btn btn-secondary" onclick="clearPoints()">Clear Points</button>
    </div>

    <h2>Connection Points</h2>
    <div class="points-list" id="points-list">
      <div class="empty-state">Click on letters to add points</div>
    </div>

    <div style="margin-top: 20px;">
      <button class="btn btn-export" onclick="exportCode()">üì¶ Export Code</button>
    </div>
  </div>

  <!-- Preview Area -->
  <div class="preview-area">
    <div class="preview-controls">
      <div class="progress-control">
        <label>Animation Progress:</label>
        <input type="range" id="progress-slider" min="0" max="100" value="100" oninput="updateProgress(this.value)">
        <span class="progress-value" id="progress-value">100%</span>
      </div>
      <button class="btn btn-secondary" onclick="animatePreview()">‚ñ∂Ô∏è Animate</button>
    </div>

    <div class="preview-panel" id="preview-panel">
      <svg class="preview-connector" id="preview-svg">
        <path id="preview-path"></path>
      </svg>
      <div class="preview-txt" id="preview-txt">
        <div class="empty-state">Enter text and click "Generate Preview"</div>
      </div>
    </div>
  </div>
</div>

<!-- Export Modal -->
<div class="modal" id="export-modal">
  <div class="modal-content">
    <h2>Exported Code</h2>
    <p style="color: #888; margin-bottom: 15px;">Copy this HTML file to use your animation:</p>
    <pre id="export-code"></pre>
    <button class="btn btn-secondary close-btn" onclick="closeModal()">Close</button>
  </div>
</div>

<script>
// Store connection points
let connectionPoints = [];
let letterElements = [];

// Generate preview from text input
function generatePreview() {
  const textInput = document.getElementById('text-input').value;
  const lines = textInput.split('\n').filter(line => line.trim());
  
  const previewTxt = document.getElementById('preview-txt');
  previewTxt.innerHTML = '';
  letterElements = [];
  
  lines.forEach((line, lineIndex) => {
    const lineDiv = document.createElement('div');
    lineDiv.className = 'preview-line';
    
    const words = line.split(/\s+/).filter(w => w);
    
    words.forEach((word, wordIndex) => {
      const wordSpan = document.createElement('span');
      wordSpan.className = 'preview-word';
      
      [...word].forEach((letter, letterIndex) => {
        const letterSpan = document.createElement('span');
        letterSpan.className = 'preview-letter';
        letterSpan.textContent = letter;
        letterSpan.dataset.line = lineIndex;
        letterSpan.dataset.word = wordIndex;
        letterSpan.dataset.letter = letterIndex;
        letterSpan.dataset.char = letter;
        letterSpan.onclick = () => togglePoint(letterSpan);
        
        letterElements.push(letterSpan);
        wordSpan.appendChild(letterSpan);
      });
      
      lineDiv.appendChild(wordSpan);
    });
    
    previewTxt.appendChild(lineDiv);
  });
  
  // Re-apply selected points
  updateSelectedLetters();
  updateConnectorPath();
}

// Toggle a connection point
function togglePoint(letterSpan) {
  const pointKey = `${letterSpan.dataset.line}-${letterSpan.dataset.word}-${letterSpan.dataset.letter}`;
  
  const existingIndex = connectionPoints.findIndex(p => p.key === pointKey);
  
  if (existingIndex >= 0) {
    // Remove point
    connectionPoints.splice(existingIndex, 1);
  } else {
    // Add point
    connectionPoints.push({
      key: pointKey,
      line: letterSpan.dataset.line,
      word: letterSpan.dataset.word,
      letter: letterSpan.dataset.letter,
      char: letterSpan.dataset.char,
      element: letterSpan
    });
  }
  
  updateSelectedLetters();
  updatePointsList();
  updateConnectorPath();
}

// Update visual selection on letters
function updateSelectedLetters() {
  letterElements.forEach(el => {
    el.classList.remove('selected');
    delete el.dataset.index;
  });
  
  connectionPoints.forEach((point, idx) => {
    const el = letterElements.find(l => 
      l.dataset.line === point.line && 
      l.dataset.word === point.word && 
      l.dataset.letter === point.letter
    );
    if (el) {
      el.classList.add('selected');
      el.dataset.index = idx + 1;
      point.element = el;
    }
  });
}

// Update the points list in sidebar
function updatePointsList() {
  const list = document.getElementById('points-list');
  
  if (connectionPoints.length === 0) {
    list.innerHTML = '<div class="empty-state">Click on letters to add points</div>';
    return;
  }
  
  list.innerHTML = connectionPoints.map((point, idx) => `
    <div class="point-item">
      <span>${idx + 1}. "${point.char}"</span>
      <span style="color: #666;">Line ${parseInt(point.line) + 1}, Word ${parseInt(point.word) + 1}</span>
      <button onclick="removePoint(${idx})">Remove</button>
    </div>
  `).join('');
}

// Remove a specific point
function removePoint(index) {
  connectionPoints.splice(index, 1);
  updateSelectedLetters();
  updatePointsList();
  updateConnectorPath();
}

// Clear all points
function clearPoints() {
  connectionPoints = [];
  updateSelectedLetters();
  updatePointsList();
  updateConnectorPath();
}

// Get center position of an element
function getCenter(el) {
  if (!el) return null;
  const rect = el.getBoundingClientRect();
  const panel = document.getElementById('preview-panel').getBoundingClientRect();
  return {
    x: rect.left + rect.width / 2 - panel.left,
    y: rect.top + rect.height / 2 - panel.top
  };
}

// Build SVG path through connection points
function buildPath(points) {
  if (points.length < 2) return '';
  
  let d = `M ${points[0].x} ${points[0].y}`;
  
  for (let i = 1; i < points.length; i++) {
    const prev = points[i - 1];
    const curr = points[i];
    const cpX = (prev.x + curr.x) / 2;
    const cpY = (prev.y + curr.y) / 2;
    d += ` Q ${cpX} ${cpY}, ${curr.x} ${curr.y}`;
  }
  
  return d;
}

// Update the connector path
function updateConnectorPath() {
  const path = document.getElementById('preview-path');
  const svg = document.getElementById('preview-svg');
  
  // Remove old dots
  svg.querySelectorAll('circle').forEach(c => c.remove());
  
  if (connectionPoints.length < 2) {
    path.setAttribute('d', '');
    return;
  }
  
  const points = connectionPoints.map(p => getCenter(p.element)).filter(p => p);
  
  if (points.length < 2) {
    path.setAttribute('d', '');
    return;
  }
  
  const d = buildPath(points);
  path.setAttribute('d', d);
  
  // Apply progress
  const progress = document.getElementById('progress-slider').value / 100;
  const pathLength = path.getTotalLength();
  
  if (pathLength > 0) {
    path.style.strokeDasharray = pathLength;
    path.style.strokeDashoffset = pathLength * (1 - progress);
    path.style.opacity = progress > 0.01 ? 1 : 0;
  }
  
  // Add dots
  points.forEach((point, idx) => {
    const circle = document.createElementNS('http://www.w3.org/2000/svg', 'circle');
    circle.setAttribute('cx', point.x);
    circle.setAttribute('cy', point.y);
    circle.setAttribute('r', 5);
    
    const threshold = (idx + 1) / points.length;
    circle.style.opacity = progress >= threshold ? 0.9 : 0;
    circle.style.fill = 'white';
    circle.style.filter = 'drop-shadow(0 0 8px rgba(126, 227, 183, 0.9))';
    
    svg.appendChild(circle);
  });
}

// Update progress from slider
function updateProgress(value) {
  document.getElementById('progress-value').textContent = value + '%';
  updateConnectorPath();
}

// Animate the preview
function animatePreview() {
  const slider = document.getElementById('progress-slider');
  slider.value = 0;
  updateProgress(0);
  
  let progress = 0;
  const interval = setInterval(() => {
    progress += 1;
    slider.value = progress;
    updateProgress(progress);
    
    if (progress >= 100) {
      clearInterval(interval);
    }
  }, 30);
}

// Export the code
function exportCode() {
  const textInput = document.getElementById('text-input').value;
  const lines = textInput.split('\n').filter(line => line.trim());
  
  // Build HTML for text with connection points
  let htmlContent = '';
  let letterIndex = 0;
  let pointIndex = 1;
  
  lines.forEach((line, lineIdx) => {
    const words = line.split(/\s+/).filter(w => w);
    let lineHtml = '      <span class="word">';
    
    words.forEach((word, wordIdx) => {
      if (wordIdx > 0) lineHtml += '</span>\n      <span class="word">';
      
      [...word].forEach((char, charIdx) => {
        const isPoint = connectionPoints.some(p => 
          parseInt(p.line) === lineIdx && 
          parseInt(p.word) === wordIdx && 
          parseInt(p.letter) === charIdx
        );
        
        if (isPoint) {
          lineHtml += `<span class="connection-point" id="letter-${pointIndex}">${char}</span>`;
          pointIndex++;
        } else {
          lineHtml += char;
        }
      });
    });
    
    lineHtml += '</span>';
    htmlContent += `    <div class="line">\n${lineHtml}\n    </div>\n`;
  });
  
  // Generate letter IDs array
  const letterIds = connectionPoints.map((_, idx) => `'letter-${idx + 1}'`).join(', ');
  const dotsHtml = connectionPoints.map((_, idx) => 
    `  <circle id="dot-${idx + 1}" r="5" opacity="0"></circle>`
  ).join('\n');
  
  const exportedCode = `<!DOCTYPE html>
<html>
<head>
<meta charset="UTF-8">
<title>LUGATANI - Connector Animation</title>
<script src="https://cdnjs.cloudflare.com/ajax/libs/gsap/3.12.2/gsap.min.js"><\/script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/gsap/3.12.2/ScrollTrigger.min.js"><\/script>
<style>
  * { margin: 0; padding: 0; box-sizing: border-box; }
  html, body {
    background: #111;
    font-family: Montserrat, sans-serif;
    overflow-x: hidden;
    scrollbar-width: none;
  }
  html::-webkit-scrollbar, body::-webkit-scrollbar { display: none; }
  
  .panel {
    height: 100vh;
    display: flex;
    align-items: center;
    justify-content: center;
    background: #111;
  }
  
  .txt { text-align: left; line-height: 0.95; }
  
  .line {
    font-size: clamp(36px, 9vw, 110px);
    font-weight: 800;
    color: #009844;
    transform: skewX(-10deg);
    display: flex;
    gap: 18px;
    margin-bottom: 5px;
  }
  
  .word { display: inline-block; transition: color 0.4s ease; }
  .word.passed { color: #006830; }
  
  .connection-point { color: #009844; transition: color 0.4s ease; }
  .connection-point.passed { color: #00c853; }
  
  svg.connector-svg {
    position: fixed;
    top: 0; left: 0;
    width: 100%; height: 100%;
    pointer-events: none;
    z-index: 50;
  }
  
  svg.connector-svg path {
    stroke: white;
    stroke-width: 2px;
    stroke-linecap: round;
    fill: none;
  }
  
  svg.connector-svg circle {
    fill: white;
    filter: drop-shadow(0 0 8px rgba(126, 227, 183, 0.9));
  }
  
  .next-section {
    height: 100vh;
    display: flex;
    align-items: center;
    justify-content: center;
    background: #1a1a1a;
  }
  .next-section h2 { color: #009844; font-size: 3rem; }
</style>
</head>
<body>

<svg class="connector-svg" id="connector-svg">
  <path id="connector-path"></path>
${dotsHtml}
</svg>

<section class="panel" id="main-panel">
  <div class="txt">
${htmlContent}  </div>
</section>

<section class="next-section">
  <h2>Continue scrolling...</h2>
</section>

<script>
gsap.registerPlugin(ScrollTrigger);

const panel = document.getElementById('main-panel');
const connPath = document.getElementById('connector-path');
const letterIds = [${letterIds}];
const dots = letterIds.map((_, i) => document.getElementById('dot-' + (i + 1)));

function getLetterCenter(id) {
  const el = document.getElementById(id);
  if (!el) return null;
  const rect = el.getBoundingClientRect();
  return { x: rect.left + rect.width / 2, y: rect.top + rect.height / 2 };
}

function buildPath() {
  const points = letterIds.map(getLetterCenter).filter(p => p);
  if (points.length < 2) return '';
  let d = \`M \${points[0].x} \${points[0].y}\`;
  for (let i = 1; i < points.length; i++) {
    const prev = points[i - 1], curr = points[i];
    d += \` Q \${(prev.x + curr.x) / 2} \${(prev.y + curr.y) / 2}, \${curr.x} \${curr.y}\`;
  }
  return d;
}

function updateConnector(progress) {
  const points = letterIds.map(getLetterCenter).filter(p => p);
  if (points.length < 2) return;
  
  connPath.setAttribute('d', buildPath());
  const len = connPath.getTotalLength();
  if (len > 0) {
    connPath.style.strokeDasharray = len;
    connPath.style.strokeDashoffset = len * (1 - progress);
    connPath.style.opacity = progress > 0.01 ? 1 : 0;
  }
  
  points.forEach((pt, idx) => {
    if (dots[idx]) {
      dots[idx].setAttribute('cx', pt.x);
      dots[idx].setAttribute('cy', pt.y);
      dots[idx].style.opacity = progress >= (idx + 1) / points.length ? 0.9 : 0;
    }
    const letter = document.getElementById(letterIds[idx]);
    if (letter) letter.classList.toggle('passed', progress >= (idx + 1) / points.length);
  });
}

ScrollTrigger.create({
  trigger: panel,
  start: 'top top',
  end: '+=400%',
  pin: true,
  pinSpacing: true,
  onUpdate: (self) => updateConnector(self.progress)
});

window.addEventListener('resize', () => ScrollTrigger.refresh());
window.addEventListener('load', () => setTimeout(() => { ScrollTrigger.refresh(); updateConnector(0); }, 500));
<\/script>

</body>
</html>`;

  document.getElementById('export-code').textContent = exportedCode;
  document.getElementById('export-modal').classList.add('active');
}

// Close modal
function closeModal() {
  document.getElementById('export-modal').classList.remove('active');
}

// Recalculate on resize
window.addEventListener('resize', () => {
  updateConnectorPath();
});

// Initial generate
generatePreview();
</script>

</body>
</html>
